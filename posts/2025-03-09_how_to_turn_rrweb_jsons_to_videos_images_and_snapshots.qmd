---
aliases:
- /how-to-turn-rrweb-jsons-to-videos-images-and-snapshots/
categories:
- Web Recording
- Data Conversion
date: '2025-03-09'
image: /images/rrweb_conversion/thumbnail.jpg
title: "How to Turn rrweb JSONs to Videos, Images, and Snapshots"
subtitle: "A practical guide to converting rrweb session recordings into various visual formats"
format: html
---

I have used PostHog for a while now. They have a bunch of features like engagement funnels and user tracking. However, one of their features that particularly was of interest to me was their session replays. The session replays look like full recordings of people's browsers as they browse your website. Can you imagine my surprise when I learned that they were not capturing your screen!? So how do they do it then? How does it look exactly like how you actually "record" your screen?

![PostHog session replay interface showing user interactions on a website](https://posthog.com/images/og/session-replay.jpg)

In this article I will go over the open-source framework of rrweb and how it on a conceptual level records our screens. Next we will create some scripts that will allow us to turn those sessions into actual videos, images, and individual HTML snapshots.


Let's Begin

## What is rrweb?

[rrweb](https://github.com/rrweb-io/rrweb) is an open-source JavaScript library that allows you to record and replay web sessions with high fidelity. The name "rrweb" stands for "record and replay the web." With over 17,000 GitHub stars, it's a popular tool used by many companies including PostHog, LogRocket, FullStory, and Hotjar for their session replay features.

Unlike traditional screen recording tools that capture pixel data, rrweb works by recording the DOM (Document Object Model) and user interactions. This approach creates lightweight, high-fidelity recordings that can be replayed with perfect visual accuracy.

### How rrweb Works

At a high level, rrweb operates through three main components:

1.  **DOM Snapshots**: rrweb takes an initial snapshot of the page's DOM structure
2.  **Event Recording**: It records all DOM mutations and user interactions as they happen
3.  **Replay**: It reconstructs the session by applying the recorded events to the initial snapshot

![rrweb architecture diagram showing the recording and replay process](https://i.imgur.com/ZhbnoJI.png)

Let's dive deeper into the technical implementation of how rrweb captures these events:

| Category | Element/Interaction | Implementation |
|----------|---------------------|----------------|
| **DOM Structure** | HTML Elements | All DOM elements in the page via `snapshot()` function |
| | Text Content | Text within elements via Mutation observer |
| | Attributes | Element attributes and properties via Mutation observer |
| | DOM Structure Changes | Elements being added or removed via Mutation observer |
| **User Interactions** | Mouse Movements | Cursor position tracking via Mouse/touch event listeners |
| | Mouse Clicks | Left/right clicks on elements via Mouse interaction observer |
| | Touch Events | Touch interactions on mobile devices via Touch event listeners |
| | Scrolling | Vertical/horizontal scrolling via Scroll observer |
| | Input Values | Text entered in form fields via Input observer |
| | Focus/Blur | Element focus and blur events via Mouse interaction observer |
| | Selection | Text selection ranges via Selection observer |
| | Checkbox/Radio Changes | State changes of form controls via Input observer |
| **Visual Elements** | CSS Styles | Inline and external CSS via StyleSheet rule observer |
| | CSS Changes | Dynamic style modifications via StyleDeclaration observer |
| | Canvas 2D | Canvas drawing operations via Canvas 2D observer |
| | WebGL Content | WebGL canvas operations via WebGL observer |
| | Fonts | Custom font loading via Font observer |
| **Media** | Video Controls | Play, pause, seek, volume via Media interaction observer |
| | Audio Controls | Play, pause, seek, volume via Media interaction observer |
| **Viewport** | Window Resize | Browser window size changes via Viewport resize observer |
| | Page Navigation | URL changes via Meta event recording |
| **Advanced Elements** | Shadow DOM | Elements in shadow DOM via Shadow DOM manager |
| | Custom Elements | Web component registration and behavior via Custom element observer |
| | iframes | Content inside same-origin iframes via iframe manager |
| | Cross-Origin iframes | Content inside cross-origin iframes via Cross-origin iframe manager |
| | Adopted Stylesheets | Programmatically created stylesheets via Adopted stylesheet observer |
| **Page State** | Scroll Position | Page and element scroll positions via Scroll observer |
| | Element Dimensions | Size and position of elements captured during DOM changes |
| | Visibility | Element visibility changes via Attribute mutation tracking |
| **Custom Data** | Developer Events | Custom events defined by developers via Custom event API |
| | Plugin Data | Data from custom plugins via Plugin architecture |

This comprehensive architecture allows rrweb to capture virtually every aspect of a web application, ensuring high-fidelity replays with minimal overhead. Each event is precisely timestamped and organized to maintain the exact sequence of user interactions and visual changes.

::: {.callout-note}
This architecture captures virtually every aspect of a web application, ensuring high-fidelity replays with minimal overhead. Each event is precisely timestamped and organized to maintain the exact sequence of user interactions and visual changes.
:::

### Understanding RRWeb's Data Serialization Process

All of this sophisticated capturing is made possible through rrweb's powerful data serialization system. Let's peek under the hood to understand how rrweb converts complex browser events into storable JSON formats.

When rrweb records a session, it creates a sequence of serialized events. Each event is a JSON object with a specific structure:

```javascript
{
  type: EventType, // Numeric identifier for the event type
  data: {/* Event-specific data */},
  timestamp: 1615482345678 // Unix timestamp when the event occurred
  sessionId: "1234567890" // Unique identifier for the session
}
```

Let's examine how different aspects of a web session are encoded:

#### DOM Structure Serialization

The initial DOM snapshot is one of the most complex parts of the recording:

```javascript
{
  type: 2, // FullSnapshot event
  data: {
    node: {
      type: 1, // Element node
      tagName: "html",
      attributes: {/* HTML attributes */},
      childNodes: [/* Recursive tree of DOM nodes */]
    },
    initialOffset: {
      left: 0,
      top: 0
    }
  },
  timestamp: 1615482345678,
  sessionId: "1234567890"
}
```

Each DOM node receives a unique ID, which is then referenced in subsequent events rather than repeating the entire node information. This "mirror system" is key to keeping data sizes manageable.

#### User Interactions

Mouse movements, clicks, and other user interactions are captured as incremental events:

```javascript
{
  type: 3, // IncrementalSnapshot event
  data: {
    source: 1, // MouseMove event source
    positions: [
      {x: 100, y: 200, id: 42, timeOffset: 123} // Mouse position
    ]
  },
  timestamp: 1615482345678,
  sessionId: "1234567890"
}
```

For high-frequency events like mouse movements, rrweb employs sampling techniques to reduce data size while maintaining visual fidelity.

#### DOM Changes

As users interact with the page, rrweb records only the changes to the DOM rather than full snapshots:

```javascript
{
  type: 3, // IncrementalSnapshot event
  data: {
    source: 0, // Mutation event
    adds: [/* Elements added to the DOM */],
    removes: [/* Elements removed from the DOM */],
    texts: [/* Text content changes */],
    attributes: [/* Attribute modifications */]
  },
  timestamp: 1615482345678,
  sessionId: "1234567890"
}
```

This incremental update approach drastically reduces data size compared to capturing full DOM snapshots repeatedly.

#### Advanced Features

rrweb also handles complex browser features like Canvas operations, WebGL content, CSS changes, and Shadow DOM:

```javascript
{
  type: 3, // IncrementalSnapshot event
  data: {
    source: 7, // CanvasMutation
    id: 45, // Canvas element ID
    commands: [
      {
        property: "fillStyle",
        args: ["#ff0000"],
        setter: true
      },
      {
        property: "fillRect",
        args: [0, 0, 100, 100]
      }
    ]
  },
  timestamp: 1615482345678,
  sessionId: "1234567890"
}
```

The serialization process follows a consistent pattern:
1. Browser events trigger rrweb observer callbacks
2. These callbacks format the data into standardized event objects
3. Events are timestamped and wrapped as `eventWithTime` objects
4. The data is serialized to a JSON-compatible format
5. Optional compression may be applied
6. Finally, the data is emitted through the provided callback

This elegant serialization system is what enables rrweb to capture the complete essence of a web session with remarkably small data sizes, typically just kilobytes per minute of recording.

## Implementing rrweb in Your Project

Now that we understand how rrweb works and how it serializes data, let's implement it in a real project. We'll cover:

1. Recording sessions
2. Saving the recordings
3. Replaying recordings
4. Converting recordings to videos and images

### Basic Recording Implementation

First, let's set up a basic recording mechanism:



``` jsx
// First, install the packages with:
// npm install rrweb rrweb-player

// In your React component:
import { record } from 'rrweb';
import rrwebPlayer from 'rrweb-player';
import 'rrweb-player/dist/style.css';
```

Let's look at a simple example of how to implement rrweb recording in a React application:

``` jsx
import { useState, useEffect } from 'react';
import { record } from 'rrweb';

function RecordingComponent() {
  const [recording, setRecording] = useState(false);
  const [events, setEvents] = useState([]);
  const [eventCount, setEventCount] = useState(0);
  
  // Function to handle recording
  const toggleRecording = () => {
    if (!recording) {
      // Clear previous recordings
      setEvents([]);
      setEventCount(0);
      
      // Start recording
      const stopFn = record({
        emit(event) {
          setEvents(prevEvents => [...prevEvents, event]);
        },
      });
      
      // Save the stop function
      setRecording({
        stopFn,
        interval: setInterval(() => {
          setEventCount(events.length);
        }, 1000)
      });
    } else {
      // Stop recording
      if (recording.stopFn) recording.stopFn();
      if (recording.interval) clearInterval(recording.interval);
      setRecording(false);
    }
  };
  
  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (recording && recording.stopFn) recording.stopFn();
      if (recording && recording.interval) clearInterval(recording.interval);
    };
  }, [recording]);
  
  return (
    <div>
      <button 
        onClick={toggleRecording}
        style={{
          backgroundColor: recording ? "#f44336" : "",
          color: recording ? "white" : ""
        }}
      >
        {recording ? "Stop Recording" : "Start Recording"}
      </button>
      
      <div style={{ marginTop: '5px', fontSize: '14px', color: recording ? "#f44336" : "green" }}>
        {recording 
          ? `Recording in progress... (${eventCount} events)` 
          : events.length > 0 
            ? `Recording stopped. ${events.length} events captured.` 
            : "Ready to record"}
      </div>
    </div>
  );
}
```

The recorded events are stored as a series of JSON objects that describe everything from mouse movements to DOM changes. A typical event might look something like this:

``` javascript
{
  type: 3, // Event type (3 represents a mouse move)
  data: {
    source: 0, // Source of the event
    positions: [{x: 100, y: 200, id: 1, timeOffset: 123}] // Mouse position
  },
  timestamp: 1615482345678 // When the event occurred
}
```

### Replaying Sessions

To replay a recorded session in React, you can use the Replayer component:

``` jsx
import { useRef, useEffect } from 'react';
import { Replayer } from 'rrweb';

function ReplayComponent({ events }) {
  const replayerRef = useRef(null);
  const containerRef = useRef(null);
  
  useEffect(() => {
    // Don't create the replayer if there are no events
    if (!events || events.length === 0) return;
    
    // Create the replayer
    const replayer = new Replayer(events, {
      root: containerRef.current,
      speed: 1,
      showMouseIndicator: true,
    });
    
    // Save reference
    replayerRef.current = replayer;
    
    // Clean up
    return () => {
      // Cleanup if needed
    };
  }, [events]);
  
  const handlePlay = () => {
    if (replayerRef.current) {
      replayerRef.current.play();
    }
  };
  
  return (
    <div>
      <button onClick={handlePlay}>Play Replay</button>
      <div 
        ref={containerRef} 
        style={{ width: '100%', height: '400px', border: '1px solid #ccc' }}
      />
    </div>
  );
}
```

For a more feature-rich player with built-in controls, you can use the rrweb-player package:

``` jsx
import { useRef, useEffect } from 'react';
import rrwebPlayer from 'rrweb-player';
import 'rrweb-player/dist/style.css';

function RRWebPlayerComponent({ events }) {
  const containerRef = useRef(null);
  
  useEffect(() => {
    if (!events || events.length === 0 || !containerRef.current) return;
    
    // Clear the container first
    containerRef.current.innerHTML = '';
    
    // Create the player
    const player = new rrwebPlayer({
      target: containerRef.current,
      props: {
        events,
        width: containerRef.current.clientWidth,
        height: 600,
        showController: true,
        autoPlay: false,
        speedOption: [1, 2, 4]
      }
    });
    
    return () => {
      // Clean up if needed
      if (player && player.destroy) player.destroy();
    };
  }, [events]);
  
  return (
    <div ref={containerRef} style={{ width: '100%' }} />
  );
}
```

### Real-World Applications

rrweb is particularly valuable for:

-   **Debugging**: Developers can see exactly what users were doing when errors occurred
-   **UX Research**: Product teams can observe how real users interact with their websites
-   **Customer Support**: Support teams can see what customers are experiencing without screen sharing
-   **Analytics**: Understanding user behavior through visual session replays

Now that we understand what rrweb is and how it works, let's explore how to convert these JSON recordings into different visual formats.

## Converting rrweb Recordings in React Applications

Let's look at how to process rrweb recordings using React components and hooks.

### Loading rrweb JSON Data

Here's how you might load and process rrweb events in a React application:

``` jsx
import { useState, useEffect } from 'react';

function EventLoader({ url, onEventsLoaded }) {
  const [events, setEvents] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function loadEvents() {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url);
        const data = await response.json();
        setEvents(data);
        if (onEventsLoaded) onEventsLoaded(data);
      } catch (err) {
        console.error('Error loading events:', err);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    
    loadEvents();
  }, [url, onEventsLoaded]);
  
  return (
    <div>
      {loading && <p>Loading events...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}
      {!loading && !error && events.length > 0 && (
        <p>Loaded {events.length} events</p>
      )}
    </div>
  );
}
```

### Generating Video Snapshots

Here's a React component to create snapshots at different points in the recording:

``` jsx
import { useState, useRef, useEffect } from 'react';
import { Replayer } from 'rrweb';
import html2canvas from 'html2canvas'; // You'll need to install this: npm install html2canvas

function SnapshotGenerator({ events }) {
  const [currentTime, setCurrentTime] = useState(0);
  const [timeRange, setTimeRange] = useState({ min: 0, max: 1000 });
  const containerRef = useRef(null);
  const replayerRef = useRef(null);
  
  useEffect(() => {
    if (!events || events.length === 0 || !containerRef.current) return;
    
    // Calculate time range
    const startTime = events[0].timestamp;
    const endTime = events[events.length - 1].timestamp;
    setTimeRange({ min: 0, max: endTime - startTime });
    
    // Create replayer
    const replayer = new Replayer(events, {
      root: containerRef.current,
      skipInactive: true,
    });
    
    replayerRef.current = replayer;
    
    // Set initial frame
    updateSnapshot(0);
    
    return () => {
      // Any cleanup needed
    };
  }, [events]);
  
  const updateSnapshot = (time) => {
    if (!replayerRef.current || !events || events.length === 0) return;
    
    const absoluteTime = events[0].timestamp + parseInt(time);
    replayerRef.current.pause(absoluteTime);
    setCurrentTime(time);
  };
  
  const takeSnapshot = async () => {
    if (!containerRef.current) return;
    
    try {
      const canvas = await html2canvas(containerRef.current);
      const screenshot = canvas.toDataURL('image/png');
      
      // Create download link
      const link = document.createElement('a');
      link.download = `snapshot-${currentTime}.png`;
      link.href = screenshot;
      link.click();
    } catch (error) {
      console.error('Error taking snapshot:', error);
    }
  };
  
  return (
    <div>
      <div>
        <label htmlFor="timeline">Timeline position (ms): {currentTime}</label>
        <input 
          type="range" 
          id="timeline" 
          min={timeRange.min} 
          max={timeRange.max} 
          step="100" 
          value={currentTime}
          onChange={(e) => updateSnapshot(e.target.value)}
          style={{ width: '100%' }}
        />
      </div>
      
      <button onClick={takeSnapshot} style={{ marginTop: '10px' }}>
        Take Snapshot
      </button>
      
      <div 
        ref={containerRef} 
        style={{ 
          width: '100%', 
          height: '400px', 
          border: '1px solid #ccc',
          marginTop: '10px',
          overflow: 'hidden'
        }}
      />
    </div>
  );
}
```

### Extracting HTML Snapshots

We can also extract the HTML state at any point in the recording using React:

``` jsx
import { useState, useEffect } from 'react';
import { Replayer } from 'rrweb';

function HtmlExtractor({ events }) {
  const [time, setTime] = useState(0);
  const [htmlContent, setHtmlContent] = useState('');
  
  const extractHtml = () => {
    if (!events || events.length === 0) {
      setHtmlContent('No events available');
      return;
    }
    
    // Create a temporary container for the replayer
    const tempContainer = document.createElement('div');
    tempContainer.style.position = 'absolute';
    tempContainer.style.left = '-9999px';
    document.body.appendChild(tempContainer);
    
    // Calculate the absolute time
    const startTime = events[0].timestamp;
    const absoluteTime = startTime + parseInt(time);
    
    // Create a replayer
    const tempReplayer = new Replayer(events, {
      root: tempContainer,
      skipInactive: true,
    });
    
    // Jump to the selected time
    tempReplayer.pause(absoluteTime);
    
    // Get the HTML content after a short delay to ensure rendering
    setTimeout(() => {
      // Get the HTML content
      const content = tempContainer.innerHTML;
      setHtmlContent(content);
      
      // Clean up
      document.body.removeChild(tempContainer);
    }, 100);
  };
  
  return (
    <div>
      <div>
        <label htmlFor="time-input">Time position (ms):</label>
        <input 
          id="time-input"
          type="number" 
          min="0" 
          value={time}
          onChange={(e) => setTime(e.target.value)}
          style={{ marginLeft: '10px' }}
        />
        <button 
          onClick={extractHtml}
          style={{ marginLeft: '10px' }}
        >
          Extract HTML
        </button>
      </div>
      
      {htmlContent && (
        <pre
          style={{
            height: '200px',
            overflow: 'auto',
            border: '1px solid #ccc',
            padding: '10px',
            background: '#f5f5f5',
            fontFamily: 'monospace',
            fontSize: '12px',
            marginTop: '10px'
          }}
        >
          {htmlContent}
        </pre>
      )}
    </div>
  );
}
```

## Practical Applications

The techniques above open up several possibilities for working with rrweb data:

### 1. Batch Processing Recordings

Using Node.js with rrweb, you can process multiple recordings in batch to generate:

-   Thumbnail images at key points in each session
-   Heatmaps of user interactions across sessions
-   Short video clips of important user journeys

### 2. Creating Shareable Reports

By embedding rrweb players and snapshots in React applications, you can create:

-   Interactive UX research reports
-   Customer journey analyses
-   Bug reproduction documentations
-   Training materials showing real user workflows

### 3. Data Analysis and Machine Learning

The event data from rrweb can be analyzed to:

-   Detect patterns in user behavior
-   Identify common points of confusion
-   Predict where users might encounter issues
-   Segment users based on their interaction patterns

## Conclusion

rrweb provides a powerful way to capture detailed web sessions without traditional screen recording. By integrating it with React applications, we can create interactive visualizations and analyses of user sessions.

Whether you're debugging customer issues, conducting UX research, or analyzing user behavior at scale, the techniques in this article should give you a solid foundation for working with rrweb recordings in various formats.

In the final section, we'll look at performance considerations and best practices for implementing rrweb in production environments.