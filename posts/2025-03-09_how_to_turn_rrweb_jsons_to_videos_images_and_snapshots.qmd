---
aliases:
- /how-to-turn-rrweb-jsons-to-videos-images-and-snapshots/
categories:
- Web Recording
- Data Conversion
date: '2025-03-09'
image: /images/rrweb_conversion/thumbnail.jpg
title: "How to Turn rrweb JSONs to Videos, Images, and Snapshots"
subtitle: "A practical guide to converting rrweb session recordings into various visual formats"
format: html
---

I have used PostHog for a while now. They have a bunch of features like engagement funnels and user tracking. However, one of their features that particularly was of interest to me was their session replays. The session replays look like full recordings of people's browsers as they browse your website. Can you imagine my surprise when I learned that they were not capturing your screen!? So how do they do it then? How does it look exactly like how you actually "record" your screen?

![PostHog session replay interface showing user interactions on a website](https://res.cloudinary.com/dmukukwp6/image/upload/v1/posthog.com/src/components/Product/ProductAnalytics/images/screenshot-product-analytics)

In this article I will go over the open-source framework of rrweb and how it on a conceptual level records our screens. Next we will create some scripts that will allow us to turn those sessions into actual videos, images, and individual HTML snapshots.

Let's Begin

## What is rrweb?

rrweb is a JavaScript library that allows you to record and replay web pages. It is a popular tool for creating interactive web recordings and is used by many companies, including PostHog. 

Unlike traditional screen recording tools that capture pixel data, rrweb works by recording the DOM (Document Object Model) and user interactions. This approach creates lightweight, high-fidelity recordings that can be replayed with perfect visual accuracy.

### How rrweb Works

At a high level, rrweb operates through three main components:

1. **DOM Snapshots**: rrweb takes an initial snapshot of the page's DOM structure
2. **Event Recording**: It records all DOM mutations and user interactions as they happen
3. **Replay**: It reconstructs the session by applying the recorded events to the initial snapshot

Let's look at a simple example of how to implement rrweb recording:

```{ojs}
// Import rrweb from CDN
rrweb = require('https://cdn.jsdelivr.net/npm/rrweb@latest/dist/rrweb.min.js')

// Array to store recorded events
events = []

// Function to start recording
startRecording = () => {
  // Start recording
  const stopFn = rrweb.record({
    emit(event) {
      // Save each event to our array
      events.push(event)
    },
  })
  
  return stopFn
}

// Button to start/stop recording
viewof recordingControl = {
  const btn = html`<button>Start Recording</button>`
  let stopFn
  let recording = false
  
  btn.onclick = () => {
    if (!recording) {
      stopFn = startRecording()
      btn.textContent = "Stop Recording"
      recording = true
    } else {
      stopFn()
      btn.textContent = "Start Recording"
      recording = false
      // Display event count
      console.log(`Recorded ${events.length} events`)
    }
  }
  
  return btn
}
```

The recorded events are stored as a series of JSON objects that describe everything from mouse movements to DOM changes. A typical event might look something like this:

```javascript
{
  type: 3, // Event type (3 represents a mouse move)
  data: {
    source: 0, // Source of the event
    positions: [{x: 100, y: 200, id: 1, timeOffset: 123}] // Mouse position
  },
  timestamp: 1615482345678 // When the event occurred
}
```

### Replaying Sessions

To replay a recorded session, you can use the Replayer class:

```{ojs}
// Import from CDN if not already imported above
rrweb = rrweb || require('https://cdn.jsdelivr.net/npm/rrweb@latest/dist/rrweb.min.js')

// Create a simple replay container
viewof replayContainer = {
  const container = html`<div style="width: 100%; height: 400px; border: 1px solid #ccc"></div>`
  return container
}

// Function to create and start the replayer
viewof replayControl = {
  const btn = html`<button>Play Replay</button>`
  let replayer
  
  btn.onclick = () => {
    if (!events || events.length === 0) {
      btn.textContent = "No events recorded yet"
      return
    }
    
    // Create a replayer instance if it doesn't exist
    if (!replayer) {
      replayer = new rrweb.Replayer(events, {
        root: replayContainer,
        speed: 1,
        showMouseIndicator: true,
      })
      btn.textContent = "Restart Replay"
    }
    
    // Start the replay
    replayer.play()
  }
  
  return btn
}
```

This creates an interactive replay that looks exactly like the original user session, complete with mouse movements, clicks, form inputs, and page changes.

### Real-World Applications

rrweb is particularly valuable for:

- **Debugging**: Developers can see exactly what users were doing when errors occurred
- **UX Research**: Product teams can observe how real users interact with their websites
- **Customer Support**: Support teams can see what customers are experiencing without screen sharing
- **Analytics**: Understanding user behavior through visual session replays

Now that we understand what rrweb is and how it works, let's explore how to convert these JSON recordings into different visual formats.

## Converting rrweb Recordings with Observable JS

While there are many ways to process rrweb recordings, one particularly powerful approach is to use Observable JS (OJS) within Quarto documents. This provides an interactive environment where you can load, process, and visualize your recordings with reactive updates.

### Setting Up rrweb in Observable JS

To use rrweb in Quarto's OJS cells, we first need to import the library. Since Observable JS supports ES modules, we can import rrweb directly from a CDN like jsDelivr:

```{ojs}
rrweb = require('https://cdn.jsdelivr.net/npm/rrweb@latest/dist/rrweb.min.js')
rrwebPlayer = require('https://cdn.jsdelivr.net/npm/rrweb-player@latest/dist/index.min.js')

// Also import the necessary CSS for the player
html`<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/rrweb-player@latest/dist/style.css">`
```

### Loading rrweb JSON Data

Next, we need to load our rrweb recordings. These are typically stored as JSON files:

```{ojs}
// Load events from a JSON file
events = FileAttachment("../data/how_to_turn_rrweb_jsons_to_videos_images_and_snapshots/sample-recording.json").json()
```

You can also create your own data processing functions in OJS to prepare the data for visualization.

### Creating an Interactive Replayer

Now we can create an interactive replayer in our Quarto document:

```{ojs}
viewof player = {
  const container = html`<div style="width: 100%; height: 600px;"></div>`;
  
  // Create the replayer once the container is connected to the DOM
  container.oninit = () => {
    const replayer = new rrwebPlayer.default({
      target: container, // The container element
      props: {
        events: events,
        width: container.clientWidth,
        height: container.clientHeight,
        showController: true,
        autoPlay: false,
        speedOption: [1, 2, 4]
      }
    });
  };
  
  return container;
}
```

### Generating Video Snapshots

One common requirement is to convert rrweb recordings into videos. While a full video export requires running rrweb in a headless browser, we can create a series of snapshots at key moments:

```{ojs}
viewof timeSlider = Inputs.range(
  [0, events[events.length - 1].timestamp - events[0].timestamp], 
  {label: "Timeline position (ms):", step: 100, value: 0}
)

viewof snapshotButton = Inputs.button("Take Snapshot")

snapshot = {
  const container = html`<div style="width: 100%; height: 400px; border: 1px solid #ccc; overflow: hidden;"></div>`;
  
  // Initialize the replayer
  let replayer;
  container.oninit = () => {
    replayer = new rrweb.Replayer(events, {
      root: container,
      skipInactive: true,
    });
    // Jump to the selected time
    replayer.pause(timeSlider + events[0].timestamp);
  };
  
  // Update when the time slider changes
  timeSlider; // Create dependency
  snapshotButton; // Create dependency
  if (replayer) {
    replayer.pause(timeSlider + events[0].timestamp);
  }
  
  return container;
}
```

### Extracting HTML Snapshots

We can also extract the HTML state at any point in the recording, which is useful for creating static snapshots of the session:

```{ojs}
htmlSnapshot = {
  // Create a temporary container for the replayer
  const tempContainer = document.createElement('div');
  tempContainer.style.position = 'absolute';
  tempContainer.style.left = '-9999px';
  document.body.appendChild(tempContainer);
  
  // Create a replayer
  const tempReplayer = new rrweb.Replayer(events, {
    root: tempContainer,
    skipInactive: true,
  });
  
  // Jump to the selected time
  tempReplayer.pause(timeSlider + events[0].timestamp);
  
  // Get the HTML content
  const html = tempContainer.innerHTML;
  
  // Clean up
  document.body.removeChild(tempContainer);
  
  // Return HTML in a pre-formatted container
  const output = html`<div style="height: 200px; overflow: auto; border: 1px solid #ccc; padding: 10px; background: #f5f5f5; font-family: monospace; font-size: 12px;"></div>`;
  output.textContent = html;
  return output;
}
```

## Practical Applications

The techniques above open up several possibilities for working with rrweb data:

### 1. Batch Processing Recordings

Using Python or Node.js with rrweb, you can process multiple recordings in batch to generate:

- Thumbnail images at key points in each session
- Heatmaps of user interactions across sessions
- Short video clips of important user journeys

### 2. Creating Shareable Reports

By embedding rrweb players and snapshots in Quarto documents, you can create:

- Interactive UX research reports
- Customer journey analyses
- Bug reproduction documentations
- Training materials showing real user workflows

### 3. Data Analysis and Machine Learning

The event data from rrweb can be analyzed to:

- Detect patterns in user behavior
- Identify common points of confusion
- Predict where users might encounter issues
- Segment users based on their interaction patterns

## Conclusion

rrweb provides a powerful way to capture detailed web sessions without traditional screen recording. By combining it with tools like Observable JS and Quarto, we can create interactive visualizations and analyses of user sessions.

Whether you're debugging customer issues, conducting UX research, or analyzing user behavior at scale, the techniques in this article should give you a solid foundation for working with rrweb recordings in various formats.

In the final section, we'll look at performance considerations and best practices for implementing rrweb in production environments.


