---
aliases:
- /how-to-turn-rrweb-jsons-to-videos-images-and-snapshots/
categories:
- Web Recording
- Data Conversion
date: '2025-03-09'
image: /images/rrweb_conversion/thumbnail.jpg
title: "How to Turn rrweb JSONs to Videos, Images, and Snapshots"
subtitle: "A practical guide to converting rrweb session recordings into various visual formats"
format: html
---

I have used PostHog for a while now. They have a bunch of features like engagement funnels and user tracking. However, one of their features that particularly was of interest to me was their session replays. The session replays look like full recordings of people's browsers as they browse your website. Can you imagine my surprise when I learned that they were not capturing your screen!? So how do they do it then? How does it look exactly like how you actually "record" your screen?

![PostHog session replay interface showing user interactions on a website](https://res.cloudinary.com/dmukukwp6/image/upload/v1/posthog.com/src/components/Product/ProductAnalytics/images/screenshot-product-analytics)

In this article I will go over the open-source framework of rrweb and how it on a conceptual level records our screens. Next we will create some scripts that will allow us to turn those sessions into actual videos, images, and individual HTML snapshots.

Let's Begin

## What is rrweb?

rrweb is a JavaScript library that allows you to record and replay web pages. It is a popular tool for creating interactive web recordings and is used by many companies, including PostHog. 

Unlike traditional screen recording tools that capture pixel data, rrweb works by recording the DOM (Document Object Model) and user interactions. This approach creates lightweight, high-fidelity recordings that can be replayed with perfect visual accuracy.

### How rrweb Works

At a high level, rrweb operates through three main components:

1. **DOM Snapshots**: rrweb takes an initial snapshot of the page's DOM structure
2. **Event Recording**: It records all DOM mutations and user interactions as they happen
3. **Replay**: It reconstructs the session by applying the recorded events to the initial snapshot

Let's look at a simple example of how to implement rrweb recording:

```javascript
import * as rrweb from 'rrweb';

// Array to store recorded events
let events = [];

// Start recording
const stopFn = rrweb.record({
  emit(event) {
    // Save each event to our array
    events.push(event);
  },
});

// Later, when you want to stop recording
stopFn();

// Now 'events' contains all the recorded session data
// You can save this JSON to replay later
console.log(events);
```

The recorded events are stored as a series of JSON objects that describe everything from mouse movements to DOM changes. A typical event might look something like this:

```javascript
{
  type: 3, // Event type (3 represents a mouse move)
  data: {
    source: 0, // Source of the event
    positions: [{x: 100, y: 200, id: 1, timeOffset: 123}] // Mouse position
  },
  timestamp: 1615482345678 // When the event occurred
}
```

### Replaying Sessions

To replay a recorded session, you can use the Replayer class:

```javascript
import { Replayer } from 'rrweb';

// Create a replayer instance
const replayer = new Replayer(events, {
  root: document.getElementById('replay-container'),
  speed: 1,
  showMouseIndicator: true,
});

// Start the replay
replayer.play();
```

This creates an interactive replay that looks exactly like the original user session, complete with mouse movements, clicks, form inputs, and page changes.

### Real-World Applications

rrweb is particularly valuable for:

- **Debugging**: Developers can see exactly what users were doing when errors occurred
- **UX Research**: Product teams can observe how real users interact with their websites
- **Customer Support**: Support teams can see what customers are experiencing without screen sharing
- **Analytics**: Understanding user behavior through visual session replays

Now that we understand what rrweb is and how it works, let's explore how to convert these JSON recordings into different visual formats.


