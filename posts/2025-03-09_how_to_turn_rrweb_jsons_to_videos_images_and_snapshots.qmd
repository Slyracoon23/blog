---
aliases:
- /how-to-turn-rrweb-jsons-to-videos-images-and-snapshots/
categories:
- Web Recording
- Data Conversion
date: '2025-03-09'
image: /images/rrweb_conversion/thumbnail.jpg
title: "How to Turn rrweb JSONs to Videos, Images, and Snapshots"
subtitle: "A practical guide to converting rrweb session recordings into various visual formats"
format: html
---

I have used PostHog for a while now. They have a bunch of features like engagement funnels and user tracking. However, one of their features that particularly was of interest to me was their session replays. The session replays look like full recordings of people's browsers as they browse your website. Can you imagine my surprise when I learned that they were not capturing your screen!? So how do they do it then? How does it look exactly like how you actually "record" your screen?

![PostHog session replay interface showing user interactions on a website](https://posthog.com/images/og/session-replay.jpg)

In this article I will go over the open-source framework of rrweb and how it on a conceptual level records our screens. Next we will create some scripts that will allow us to turn those sessions into actual videos, images, and individual HTML snapshots.


Let's Begin

## What is rrweb?

[rrweb](https://github.com/rrweb-io/rrweb) is an open-source JavaScript library that allows you to record and replay web sessions with high fidelity. The name "rrweb" stands for "record and replay the web." With over 17,000 GitHub stars, it's a popular tool used by many companies including PostHog, LogRocket, FullStory, and Hotjar for their session replay features.

Unlike traditional screen recording tools that capture pixel data, rrweb works by recording the DOM (Document Object Model) and user interactions. This approach creates lightweight, high-fidelity recordings that can be replayed with perfect visual accuracy.

### How rrweb Works

At a high level, rrweb operates through three main components:

1.  **DOM Snapshots**: rrweb takes an initial snapshot of the page's DOM structure
2.  **Event Recording**: It records all DOM mutations and user interactions as they happen
3.  **Replay**: It reconstructs the session by applying the recorded events to the initial snapshot

Let's dive deeper into the technical implementation of how rrweb captures these events:

#### Initial DOM Snapshot

When recording begins, rrweb creates a complete serialized representation of the page's DOM:

**DOM Serialization Process**

* **Document Traversal**: It traverses the entire document structure
* **Element Attributes**: Captures all element attributes and their values
* **Style Information**: Records CSS styles and computed styles
* **Structural Hierarchy**: Preserves the structural hierarchy of the document

This initial snapshot serves as the foundation upon which all subsequent changes are applied.

#### Event Recording System

Once the baseline is established, rrweb employs various observers to track changes:

**DOM Mutations**

* Uses MutationObserver to watch all changes to DOM structure
* Tracks node additions, removals, and attribute changes
* Records text content modifications
* Monitors elements being inserted, removed, or rearranged
* Captures changes to inline styles and attributes

**User Interactions**

* **Mouse Movements**: Records cursor positions with timestamps and throttles for efficiency
* **Mouse Events**: Captures clicks, double-clicks, context menus, focus, and blur events
* **Scrolling**: Tracks scroll positions for the viewport and all scrollable elements
* **Input Events**: Records typing, selections, checkboxes, radio buttons, and form interactions
* **Touch Events**: Supports mobile touch interactions including multi-touch gestures

**Visual State Changes**

* **Viewport Resize**: Records changes to window dimensions and orientation
* **StyleSheet Rules**: Captures additions and removals of CSS rules in stylesheets
* **Canvas Operations**: Records drawing commands on both 2D and WebGL canvas contexts
* **Media Interactions**: Tracks play, pause, volume, and seeking actions for audio/video elements
* **CSS Animations**: Preserves CSS animation states and transitions

**Special Features**

* **Font Loading**: Monitors custom font loading to ensure text renders correctly
* **Shadow DOM**: Captures encapsulated shadow root content while maintaining boundaries
* **Custom Elements**: Records definitions and behaviors of web components
* **Cross-origin Iframes**: Supports recording content in iframes (with proper configuration)
* **Selection States**: Tracks text selection ranges and focus areas
* **Network Resource Timing**: Records resource loading performance for key assets

**Event Types**

* **Full Snapshots**: Complete DOM state captures
* **Incremental Events**: Small changes that happened between snapshots
* **Meta Events**: Recording metadata and configuration
* **Custom Events**: User-defined markers and data points

This rich event-based architecture allows rrweb to capture virtually every aspect of a web application, ensuring high-fidelity replays with minimal overhead. Each event is precisely timestamped and organized to maintain the exact sequence of user interactions and visual changes.

``` jsx
// First, install the packages with:
// npm install rrweb rrweb-player

// In your React component:
import { record } from 'rrweb';
import rrwebPlayer from 'rrweb-player';
import 'rrweb-player/dist/style.css';
```

Let's look at a simple example of how to implement rrweb recording in a React application:

``` jsx
import { useState, useEffect } from 'react';
import { record } from 'rrweb';

function RecordingComponent() {
  const [recording, setRecording] = useState(false);
  const [events, setEvents] = useState([]);
  const [eventCount, setEventCount] = useState(0);
  
  // Function to handle recording
  const toggleRecording = () => {
    if (!recording) {
      // Clear previous recordings
      setEvents([]);
      setEventCount(0);
      
      // Start recording
      const stopFn = record({
        emit(event) {
          setEvents(prevEvents => [...prevEvents, event]);
        },
      });
      
      // Save the stop function
      setRecording({
        stopFn,
        interval: setInterval(() => {
          setEventCount(events.length);
        }, 1000)
      });
    } else {
      // Stop recording
      if (recording.stopFn) recording.stopFn();
      if (recording.interval) clearInterval(recording.interval);
      setRecording(false);
    }
  };
  
  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (recording && recording.stopFn) recording.stopFn();
      if (recording && recording.interval) clearInterval(recording.interval);
    };
  }, [recording]);
  
  return (
    <div>
      <button 
        onClick={toggleRecording}
        style={{
          backgroundColor: recording ? "#f44336" : "",
          color: recording ? "white" : ""
        }}
      >
        {recording ? "Stop Recording" : "Start Recording"}
      </button>
      
      <div style={{ marginTop: '5px', fontSize: '14px', color: recording ? "#f44336" : "green" }}>
        {recording 
          ? `Recording in progress... (${eventCount} events)` 
          : events.length > 0 
            ? `Recording stopped. ${events.length} events captured.` 
            : "Ready to record"}
      </div>
    </div>
  );
}
```

The recorded events are stored as a series of JSON objects that describe everything from mouse movements to DOM changes. A typical event might look something like this:

``` javascript
{
  type: 3, // Event type (3 represents a mouse move)
  data: {
    source: 0, // Source of the event
    positions: [{x: 100, y: 200, id: 1, timeOffset: 123}] // Mouse position
  },
  timestamp: 1615482345678 // When the event occurred
}
```

### Replaying Sessions

To replay a recorded session in React, you can use the Replayer component:

``` jsx
import { useRef, useEffect } from 'react';
import { Replayer } from 'rrweb';

function ReplayComponent({ events }) {
  const replayerRef = useRef(null);
  const containerRef = useRef(null);
  
  useEffect(() => {
    // Don't create the replayer if there are no events
    if (!events || events.length === 0) return;
    
    // Create the replayer
    const replayer = new Replayer(events, {
      root: containerRef.current,
      speed: 1,
      showMouseIndicator: true,
    });
    
    // Save reference
    replayerRef.current = replayer;
    
    // Clean up
    return () => {
      // Cleanup if needed
    };
  }, [events]);
  
  const handlePlay = () => {
    if (replayerRef.current) {
      replayerRef.current.play();
    }
  };
  
  return (
    <div>
      <button onClick={handlePlay}>Play Replay</button>
      <div 
        ref={containerRef} 
        style={{ width: '100%', height: '400px', border: '1px solid #ccc' }}
      />
    </div>
  );
}
```

For a more feature-rich player with built-in controls, you can use the rrweb-player package:

``` jsx
import { useRef, useEffect } from 'react';
import rrwebPlayer from 'rrweb-player';
import 'rrweb-player/dist/style.css';

function RRWebPlayerComponent({ events }) {
  const containerRef = useRef(null);
  
  useEffect(() => {
    if (!events || events.length === 0 || !containerRef.current) return;
    
    // Clear the container first
    containerRef.current.innerHTML = '';
    
    // Create the player
    const player = new rrwebPlayer({
      target: containerRef.current,
      props: {
        events,
        width: containerRef.current.clientWidth,
        height: 600,
        showController: true,
        autoPlay: false,
        speedOption: [1, 2, 4]
      }
    });
    
    return () => {
      // Clean up if needed
      if (player && player.destroy) player.destroy();
    };
  }, [events]);
  
  return (
    <div ref={containerRef} style={{ width: '100%' }} />
  );
}
```

### Real-World Applications

rrweb is particularly valuable for:

-   **Debugging**: Developers can see exactly what users were doing when errors occurred
-   **UX Research**: Product teams can observe how real users interact with their websites
-   **Customer Support**: Support teams can see what customers are experiencing without screen sharing
-   **Analytics**: Understanding user behavior through visual session replays

Now that we understand what rrweb is and how it works, let's explore how to convert these JSON recordings into different visual formats.

## Converting rrweb Recordings in React Applications

Let's look at how to process rrweb recordings using React components and hooks.

### Loading rrweb JSON Data

Here's how you might load and process rrweb events in a React application:

``` jsx
import { useState, useEffect } from 'react';

function EventLoader({ url, onEventsLoaded }) {
  const [events, setEvents] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function loadEvents() {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url);
        const data = await response.json();
        setEvents(data);
        if (onEventsLoaded) onEventsLoaded(data);
      } catch (err) {
        console.error('Error loading events:', err);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    
    loadEvents();
  }, [url, onEventsLoaded]);
  
  return (
    <div>
      {loading && <p>Loading events...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}
      {!loading && !error && events.length > 0 && (
        <p>Loaded {events.length} events</p>
      )}
    </div>
  );
}
```

### Generating Video Snapshots

Here's a React component to create snapshots at different points in the recording:

``` jsx
import { useState, useRef, useEffect } from 'react';
import { Replayer } from 'rrweb';
import html2canvas from 'html2canvas'; // You'll need to install this: npm install html2canvas

function SnapshotGenerator({ events }) {
  const [currentTime, setCurrentTime] = useState(0);
  const [timeRange, setTimeRange] = useState({ min: 0, max: 1000 });
  const containerRef = useRef(null);
  const replayerRef = useRef(null);
  
  useEffect(() => {
    if (!events || events.length === 0 || !containerRef.current) return;
    
    // Calculate time range
    const startTime = events[0].timestamp;
    const endTime = events[events.length - 1].timestamp;
    setTimeRange({ min: 0, max: endTime - startTime });
    
    // Create replayer
    const replayer = new Replayer(events, {
      root: containerRef.current,
      skipInactive: true,
    });
    
    replayerRef.current = replayer;
    
    // Set initial frame
    updateSnapshot(0);
    
    return () => {
      // Any cleanup needed
    };
  }, [events]);
  
  const updateSnapshot = (time) => {
    if (!replayerRef.current || !events || events.length === 0) return;
    
    const absoluteTime = events[0].timestamp + parseInt(time);
    replayerRef.current.pause(absoluteTime);
    setCurrentTime(time);
  };
  
  const takeSnapshot = async () => {
    if (!containerRef.current) return;
    
    try {
      const canvas = await html2canvas(containerRef.current);
      const screenshot = canvas.toDataURL('image/png');
      
      // Create download link
      const link = document.createElement('a');
      link.download = `snapshot-${currentTime}.png`;
      link.href = screenshot;
      link.click();
    } catch (error) {
      console.error('Error taking snapshot:', error);
    }
  };
  
  return (
    <div>
      <div>
        <label htmlFor="timeline">Timeline position (ms): {currentTime}</label>
        <input 
          type="range" 
          id="timeline" 
          min={timeRange.min} 
          max={timeRange.max} 
          step="100" 
          value={currentTime}
          onChange={(e) => updateSnapshot(e.target.value)}
          style={{ width: '100%' }}
        />
      </div>
      
      <button onClick={takeSnapshot} style={{ marginTop: '10px' }}>
        Take Snapshot
      </button>
      
      <div 
        ref={containerRef} 
        style={{ 
          width: '100%', 
          height: '400px', 
          border: '1px solid #ccc',
          marginTop: '10px',
          overflow: 'hidden'
        }}
      />
    </div>
  );
}
```

### Extracting HTML Snapshots

We can also extract the HTML state at any point in the recording using React:

``` jsx
import { useState, useEffect } from 'react';
import { Replayer } from 'rrweb';

function HtmlExtractor({ events }) {
  const [time, setTime] = useState(0);
  const [htmlContent, setHtmlContent] = useState('');
  
  const extractHtml = () => {
    if (!events || events.length === 0) {
      setHtmlContent('No events available');
      return;
    }
    
    // Create a temporary container for the replayer
    const tempContainer = document.createElement('div');
    tempContainer.style.position = 'absolute';
    tempContainer.style.left = '-9999px';
    document.body.appendChild(tempContainer);
    
    // Calculate the absolute time
    const startTime = events[0].timestamp;
    const absoluteTime = startTime + parseInt(time);
    
    // Create a replayer
    const tempReplayer = new Replayer(events, {
      root: tempContainer,
      skipInactive: true,
    });
    
    // Jump to the selected time
    tempReplayer.pause(absoluteTime);
    
    // Get the HTML content after a short delay to ensure rendering
    setTimeout(() => {
      // Get the HTML content
      const content = tempContainer.innerHTML;
      setHtmlContent(content);
      
      // Clean up
      document.body.removeChild(tempContainer);
    }, 100);
  };
  
  return (
    <div>
      <div>
        <label htmlFor="time-input">Time position (ms):</label>
        <input 
          id="time-input"
          type="number" 
          min="0" 
          value={time}
          onChange={(e) => setTime(e.target.value)}
          style={{ marginLeft: '10px' }}
        />
        <button 
          onClick={extractHtml}
          style={{ marginLeft: '10px' }}
        >
          Extract HTML
        </button>
      </div>
      
      {htmlContent && (
        <pre
          style={{
            height: '200px',
            overflow: 'auto',
            border: '1px solid #ccc',
            padding: '10px',
            background: '#f5f5f5',
            fontFamily: 'monospace',
            fontSize: '12px',
            marginTop: '10px'
          }}
        >
          {htmlContent}
        </pre>
      )}
    </div>
  );
}
```

## Practical Applications

The techniques above open up several possibilities for working with rrweb data:

### 1. Batch Processing Recordings

Using Node.js with rrweb, you can process multiple recordings in batch to generate:

-   Thumbnail images at key points in each session
-   Heatmaps of user interactions across sessions
-   Short video clips of important user journeys

### 2. Creating Shareable Reports

By embedding rrweb players and snapshots in React applications, you can create:

-   Interactive UX research reports
-   Customer journey analyses
-   Bug reproduction documentations
-   Training materials showing real user workflows

### 3. Data Analysis and Machine Learning

The event data from rrweb can be analyzed to:

-   Detect patterns in user behavior
-   Identify common points of confusion
-   Predict where users might encounter issues
-   Segment users based on their interaction patterns

## Conclusion

rrweb provides a powerful way to capture detailed web sessions without traditional screen recording. By integrating it with React applications, we can create interactive visualizations and analyses of user sessions.

Whether you're debugging customer issues, conducting UX research, or analyzing user behavior at scale, the techniques in this article should give you a solid foundation for working with rrweb recordings in various formats.

In the final section, we'll look at performance considerations and best practices for implementing rrweb in production environments.