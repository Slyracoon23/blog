<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Earl Potters">
<meta name="dcterms.date" content="2025-04-19">

<title>How to Measure SQL Query Performance on Postgres – Earl Potters</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="..//images/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-46f4cc9626f044588a66931b604fc9c8.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-86ca98530662af5ddd08d363d7d219b9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-4DWYJM47PC"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4DWYJM47PC', { 'anonymize_ip': true});
</script>
<script src="../assets/citations.js"></script>
<script>
    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init capture register register_once register_for_session unregister unregister_for_session getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty createPersonProfile opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing debug getPageViewId captureTraceFeedback captureTraceMetric".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
    posthog.init('phc_3LFGZh7SWQGVrh5GwvDO3qwdESpdJb9AnpJHks39zdA', {
        api_host: 'https://us.i.posthog.com',
        person_profiles: 'always',
    })
</script>


<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="../assets/citations.css">
<meta property="og:title" content="How to Measure SQL Query Performance on Postgres – Earl Potters">
<meta property="og:description" content="A practical guide to benchmarking and optimizing your PostgreSQL queries">
<meta property="og:image" content="https://slyracoon23.github.io/blog/images/sql_query_performance_postgres/thumbnail.png">
<meta property="og:site_name" content="Earl Potters">
<meta property="og:image:height" content="1024">
<meta property="og:image:width" content="1536">
<meta name="twitter:title" content="How to Measure SQL Query Performance on Postgres – Earl Potters">
<meta name="twitter:description" content="A practical guide to benchmarking and optimizing your PostgreSQL queries">
<meta name="twitter:image" content="https://slyracoon23.github.io/blog/images/sql_query_performance_postgres/thumbnail.png">
<meta name="twitter:image-height" content="1024">
<meta name="twitter:image-width" content="1536">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Earl Potters</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text"><i class="fa-solid fa-address-card" aria-label="address-card"></i> About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../posts.html"> 
<span class="menu-text"><i class="fa-solid fa-newspaper" aria-label="newspaper"></i> Posts</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/SRacoon23"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/earl-potters-b2b306187/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Slyracoon23"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://huggingface.co/Slyracoon23"> 
<span class="menu-text"><img src="https://mlabonne.github.io/blog/images/hf-icon.svg" class="img-fluid"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../posts/2025-04-19_sql_query_performance_postgres.html">🗄️ <strong>Databases</strong></a></li><li class="breadcrumb-item"><a href="../posts/2025-04-19_sql_query_performance_postgres.html">How to Measure SQL Query Performance on Postgres</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../posts/2025-04-19_sql_query_performance_postgres.html">🗄️ <strong>Databases</strong></a></li><li class="breadcrumb-item"><a href="../posts/2025-04-19_sql_query_performance_postgres.html">How to Measure SQL Query Performance on Postgres</a></li></ol></nav>
      <h1 class="title">How to Measure SQL Query Performance on Postgres</h1>
            <p class="subtitle lead">A practical guide to benchmarking and optimizing your PostgreSQL queries</p>
                                <div class="quarto-categories">
                <div class="quarto-category">Databases</div>
                <div class="quarto-category">PostgreSQL</div>
                <div class="quarto-category">Performance</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Earl Potters </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 19, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">🤖 <strong>AI Agents</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-06-06_ai_engineer_worlds_fair.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Engineer World’s Fair</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">🗣️ <strong>Large Language Models</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-03-15_what_is_prompt_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">What is Prompt Engineering?</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-03-16_what_are_image_embeddings.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">What are Image Embeddings?</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-03-18_exploring_gemma_3_model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring Gemma 3 Model</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-03-21_eleutherai-evaluation-methods.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">EleutherAI’s lm-evaluation-harness</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-04-05_model_context_protocol_tool_poisoning_attacks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model Context Protocol Tool Poisoning Attacks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-04-27_gemini-image-segmentation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Gemini Image Segmentation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-05-04_game_of_ethics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">A Game of Ethics: Quantifying AI Moral Reasoning</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">🌐 <strong>Web Technologies</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-03-14_what_is_rrweb.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">What is rrweb?</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">🗄️ <strong>Databases</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-04-19_sql_query_performance_postgres.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">How to Measure SQL Query Performance on Postgres</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">📝 <strong>Writing &amp; Content</strong></span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../posts/2025-03-24_how_to_stop_being_accused_of_ai_slop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">How to Stop Being Accused of AI Slop</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title"><strong>Sections</strong></h2>
   
  <ul class="collapse">
  <li><a href="#introduction-to-postgresql-and-its-architecture" id="toc-introduction-to-postgresql-and-its-architecture" class="nav-link active" data-scroll-target="#introduction-to-postgresql-and-its-architecture">Introduction to PostgreSQL and Its Architecture</a></li>
  <li><a href="#sql-queries-under-the-hood-select-where-join-order-by" id="toc-sql-queries-under-the-hood-select-where-join-order-by" class="nav-link" data-scroll-target="#sql-queries-under-the-hood-select-where-join-order-by">SQL Queries Under the Hood: SELECT, WHERE, JOIN, ORDER BY</a></li>
  <li><a href="#why-queries-can-be-slow-understanding-query-latency" id="toc-why-queries-can-be-slow-understanding-query-latency" class="nav-link" data-scroll-target="#why-queries-can-be-slow-understanding-query-latency">Why Queries Can Be Slow: Understanding Query Latency</a></li>
  <li><a href="#tools-for-analyzing-query-performance" id="toc-tools-for-analyzing-query-performance" class="nav-link" data-scroll-target="#tools-for-analyzing-query-performance">Tools for Analyzing Query Performance</a></li>
  <li><a href="#hands-on-tuning-query-performance-dockerized-postgres-tutorial" id="toc-hands-on-tuning-query-performance-dockerized-postgres-tutorial" class="nav-link" data-scroll-target="#hands-on-tuning-query-performance-dockerized-postgres-tutorial">Hands-On: Tuning Query Performance (Dockerized Postgres Tutorial)</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><strong>TL;DR:</strong> In this post we’ll introduce PostgreSQL’s architecture and walk through how SQL queries are executed under the hood. We’ll explore why some queries are slow, and use tools like <code>EXPLAIN</code>, <code>EXPLAIN ANALYZE</code>, and <code>pg_stat_statements</code> to diagnose performance. In the second half, we get hands-on: spinning up a Dockerized PostgreSQL, loading sample data, and optimizing some slow queries (with a bit of wit and lots of technical insight along the way).</p>
<p>Grab a coffee — let’s dive in!</p>
<section id="introduction-to-postgresql-and-its-architecture" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-postgresql-and-its-architecture">Introduction to PostgreSQL and Its Architecture</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/d0gT1YZ.jpeg" class="img-fluid figure-img"></p>
<figcaption>PostgreSQL Architecture: postmaster, backends, background workers, shared memory</figcaption>
</figure>
</div>
<p>PostgreSQL (aka “Postgres”) is a powerful open-source relational database known for its robustness and extensibility. It has a <strong>client-server architecture</strong>: your application (the client) connects to the PostgreSQL server which manages your data. Unlike some systems that use threads, Postgres uses a <strong>process-per-connection model</strong>. This means each new client connection forks a new process on the server.</p>
<p>When Postgres starts up, a <strong>postmaster</strong> (master process) is launched to handle initialization and then listen for connections. For every client that connects, the postmaster forks a <strong>backend process</strong> to handle that session’s queries. In addition, Postgres runs a handful of <strong>background processes</strong> to maintain the database: a write-ahead log (WAL) writer to ensure durability, a background writer and checkpointer to flush cached data to disk, an autovacuum daemon to clean up old rows, etc. All these processes communicate via shared memory for efficiency. The shared memory contains the <strong>buffer cache</strong> (shared buffers) where frequently used data pages are kept, as well as the <strong>WAL buffers</strong> for transactional logs. In short, the architecture ensures that Postgres can handle multiple clients at once, each with their own process, while sharing common data and coordinating through background workers.</p>
<p><strong>Why does this matter for performance?</strong> Understanding the architecture helps explain behaviors like: if you have too many connections, the OS has to juggle many Postgres processes (which can exhaust CPU/RAM and lead to context-switching overhead). It also explains why data caching is so important — Postgres will keep frequently accessed rows in shared memory (shared buffers) to avoid slow disk reads. And because each backend is isolated in its own process, heavy queries on one connection won’t directly crash others, but they might contend for shared resources (like buffer memory or CPU).</p>
</section>
<section id="sql-queries-under-the-hood-select-where-join-order-by" class="level2">
<h2 class="anchored" data-anchor-id="sql-queries-under-the-hood-select-where-join-order-by">SQL Queries Under the Hood: SELECT, WHERE, JOIN, ORDER BY</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/rdgrfnl.jpeg" class="img-fluid figure-img"></p>
<figcaption>SQL Query Lifecycle: SQL → Parser → Planner → Executor → Plan Tree</figcaption>
</figure>
</div>
<p>Writing an SQL query in Postgres is declarative — you describe <em>what</em> data you want, and the database engine figures out <em>how</em> to get it. Under the hood, PostgreSQL parses your SQL, generates a <strong>query plan</strong>, and executes that plan step by step. To a developer, <code>SELECT * FROM users WHERE id = 123;</code> is one line of code; to Postgres, it’s a series of operations: scan a table (or index), filter rows, and return results. Let’s break down the basic SQL operations and what the database does under the hood:</p>
<ul>
<li><strong>SELECT-FROM (Table Scan):</strong> When you select data, Postgres needs to retrieve rows from the table (the <code>FROM</code> clause). The simplest approach is a <strong>sequential scan</strong> (“Seq Scan”) which reads all rows of the table one-by-one. This is fine for small tables or when you need most of the data, but it’s slow if you only need a few rows out of a large table. If an appropriate <strong>index</strong> exists, Postgres can do an <strong>index scan</strong> to find specific rows quickly (<a href="https://supabase.com/docs/guides/database/query-optimization">Supabase documentation explains these operations well</a>). Think of a sequential scan like reading an entire phone book to find one name, versus an index scan like flipping directly to the “Smith” section. PostgreSQL supports different index types (B-tree indexes are the common default) which are optimized tree structures that allow logarithmic-time lookups (<a href="https://www.postgresql.org/docs/current/indexes.html">PostgreSQL documentation on indexes</a>). An index scan uses these structures to jump directly to matching data rather than scanning everything.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/IQPxmOE.jpeg" class="img-fluid figure-img"></p>
<figcaption>Table Scan vs Index Scan: all rows read vs targeted lookup via B-tree</figcaption>
</figure>
</div>
<ul>
<li><p><strong>WHERE (Filtering):</strong> The WHERE clause is a filter on rows. If there’s an index on the filtered column(s), the planner may use an <strong>Index Scan</strong> with an index <strong>condition</strong> to retrieve only matching rows (e.g.&nbsp;using a B-tree index to find <code>value = 100</code>). Without an index, the executor will do a Seq Scan and check each row against the WHERE condition, discarding those that don’t match (this is essentially a <strong>filter</strong> operation on each tuple). Under the hood, each row is pulled from storage and the condition is evaluated; rows that fail the condition are skipped. This is why missing indexes on frequently searched columns can cause big slowdowns – the database ends up doing a lot of extra work scanning irrelevant rows.</p></li>
<li><p><strong>JOIN (Combining Tables):</strong> SQL joins combine rows from multiple tables. PostgreSQL’s query planner can choose among several <strong>join algorithms</strong>: <strong>Nested Loop, Hash Join,</strong> or <strong>Merge Join</strong>. A Nested Loop Join is simple: for each row in table A, scan table B for matches (perhaps using an index on B if available). This works fine for small tables or when an index can limit the inner loop, but it can become slow if both tables are large (O(N×M) in the worst case). A Hash Join is often faster for larger data sets: Postgres will read the smaller table, build an in-memory hash table by the join key, then scan the larger table and probe the hash table for matches (<a href="https://www.pgmustard.com/blog/joins-in-postgresql">PgMustard has a great explanation of join types</a>). This way, each table is scanned just once (ideal for equality joins). A Merge Join is used when both inputs are already sorted on the join key (or can be sorted cheaply). The database can then step through two sorted lists in order, like merging two sorted files, which is very efficient. Each algorithm has its sweet spot: nested loops for small or index-driven joins, hash for large unsorted joins, and merge for pre-sorted data. The planner will estimate costs and pick what it thinks is best – and it usually does a good job, though occasionally it might guess wrong.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/4DkyrCo.jpeg" class="img-fluid figure-img"></p>
<figcaption>Join Algorithms: Nested Loop, Hash Join, Merge Join — visualized with two tables and arrows showing matching process</figcaption>
</figure>
</div>
<ul>
<li><p><strong>ORDER BY (Sorting):</strong> After getting the result rows, if an ordering is required, Postgres must ensure the output is sorted. This might involve a <strong>sort operation</strong> (quickSort or similar under the hood) on the result set. Sorting is O(N log N) so it adds latency, especially for large N. However, if there is an index on the column(s) used in ORDER BY, the planner can sometimes skip an explicit sort by scanning the index in order. For example, if you do <code>SELECT * FROM items ORDER BY created_at</code>, and <code>created_at</code> has an index, Postgres can perform an <strong>Index Scan</strong> that returns rows already sorted by <code>created_at</code> – essentially killing two birds with one stone (getting data and sorting it). In execution, an ORDER BY without an index will pull all results then sort them, which can be memory-intensive (and may spill to disk if the data is huge and memory is limited). This is a common culprit for slow queries if not planned carefully.</p></li>
<li><p><strong>Other operations:</strong> There’s more under the hood (GROUP BY aggregations, LIMIT/OFFSET pagination, etc.), but they build on similar principles. For example, a <code>GROUP BY</code> may use hashing (Hash Aggregate) or sorting (Sort + Aggregate) depending on context. A <code>LIMIT 10</code> can allow the planner to do less work (it might use an index to avoid scanning the whole table if only a few rows are needed). Understanding the basic scans, joins, and sorts gives you a foundation for reasoning about these as well.</p></li>
</ul>
<p>In summary, a SQL query is translated into a tree of plan nodes: at the bottom are scan nodes pulling data from tables (via sequential or index scans) and above them are join nodes combining data, filter nodes applying WHERE conditions, and possibly sort nodes, etc. The executor pulls rows through this tree. Knowing this, we can already guess why some queries are slower than others: a query that does a full table scan of 10 million rows and sorts them will be orders of magnitude slower than one that uses indexes to fetch 5 rows and does no sort. But there are also more subtle factors, which we’ll cover next.</p>
</section>
<section id="why-queries-can-be-slow-understanding-query-latency" class="level2">
<h2 class="anchored" data-anchor-id="why-queries-can-be-slow-understanding-query-latency">Why Queries Can Be Slow: Understanding Query Latency</h2>
<p>Even with the same data and schema, query performance can differ dramatically based on how the query is written and how Postgres executes it. Here are the key factors that contribute to query latency:</p>
<ul>
<li><p><strong>Amount of Data Scanned:</strong> The more rows the database has to examine, the longer it takes. This is why <strong>indexing</strong> is so crucial: a query that scans 100,000 rows (because of no useful index) will usually be slower than a query that uses an index to scan 100 rows. Sequential I/O through a large table is slow (it may involve lots of disk reads unless the data is fully cached in RAM). If your query is filtering or joining but not using indexes effectively, you’ll end up reading a ton of unnecessary rows. For example, a sequential scan reads <em>all</em> rows from a table, so if your table is huge and you only needed a few, that’s wasted work (<a href="https://www.citusdata.com/blog/2017/10/20/efficient-sql-workload/">Citus Data has a good article on this</a>).</p></li>
<li><p><strong>Complexity of Joins and Operations:</strong> As described, join algorithms have different costs. A poorly planned join (e.g., nested loop over two large tables without indexes) can be extremely slow. Likewise, operations like sorting or aggregation can be costly if they involve many rows. A query that joins multiple tables and sorts the result will inherently do more work than a simple single-table lookup. The number of steps (plan nodes) and the nature of those steps (e.g.&nbsp;hashing, sorting, etc.) add to latency.</p></li>
<li><p><strong>Disk I/O vs Memory:</strong> Reading from memory is orders of magnitude faster than reading from disk. If your data is already in Postgres’s shared buffers (or the OS cache), a scan can be quite fast. But if the data is not cached and the query triggers a lot of disk reads, you pay a heavy penalty for disk I/O (<a href="https://www.pgcasts.com/episodes/explaining-disk-io-in-postgresql">PgCasts has a great episode on this</a>). This is why the first run of a query might be slower than subsequent runs (warm cache effect). Large result sets also mean more data to transfer over the network to the client, which can be a bottleneck by itself.</p></li>
<li><p><strong>Query Execution Plans (Bad Estimates):</strong> Postgres uses a cost-based optimizer. It makes estimates of how many rows will result from each step. If the statistics are off (e.g., you haven’t run ANALYZE recently, or data is very skewed), the planner might pick a suboptimal plan. For instance, if the planner <em>thinks</em> a filter will match 100 rows but in reality it matches 100,000, it might choose a nested loop join expecting 100 iterations, but ends up doing 100k – ouch. Mismatches between estimated rows vs actual rows can lead to bad decisions and thus slow execution (<a href="https://aws.amazon.com/blogs/database/understanding-autovacuum-in-amazon-rds-for-postgresql-environments/">AWS has a good article on statistics</a>). Regularly analyzing tables helps the optimizer make informed choices.</p></li>
<li><p><strong>Locks and Contention:</strong> If your query is waiting for another transaction’s lock (e.g., trying to read a row that’s being modified), it will be blocked until the lock is released. This appears as “latency” from the outside. High write activity or frequent locking (e.g., updates on the same rows) can therefore slow down queries due to waiting, even if the plan itself is fine (<a href="https://wiki.postgresql.org/wiki/Lock_Monitoring">PostgreSQL Wiki on lock monitoring</a>).</p></li>
<li><p><strong>Connection Overhead:</strong> Each new client connection in Postgres is a new process, which isn’t free. If an application opens and closes connections for each query (without pooling), the connection setup/teardown can add latency. Typically, this is mitigated by using connection pools so queries reuse existing backend processes rather than constantly forking new ones. Without pooling, <strong>excessive connections</strong> or frequent connect/disconnect can bog down the server (<a href="https://www.pgbouncer.org/usage.html">PgBouncer documentation</a>).</p></li>
<li><p><strong>Server Resources and Configuration:</strong> Lastly, the hardware and config matter. If your server is low on RAM, it can’t cache much data. If <code>work_mem</code> (memory for operations like sorts or hashes) is too low, queries might spill to disk during sorting or hashing, drastically slowing those operations. If the CPU is slow or overloaded, query execution waits behind other work. If the disk is slow, I/O-bound queries suffer. And as mentioned, if you have, say, 100 active heavy queries at once (high concurrency), they compete for CPU, I/O and memory, each running slower than if they ran alone (<a href="https://www.postgresql.org/docs/current/runtime-config.html">PostgreSQL documentation on server configuration</a>).</p></li>
</ul>
<p>To sum up, <strong>query latency = time spent reading data + processing it + waiting on any resources.</strong> Big data volume, inefficient plan (lack of indexes or bad join method), and disk I/O are the big three for slow queries. In the real world, performance issues often come down to “the database is doing more work than it ideally should” – our job is to find out <em>why</em> and reduce the workload (or give it more resources). Thankfully, PostgreSQL provides great tools to analyze and tune query performance.</p>
</section>
<section id="tools-for-analyzing-query-performance" class="level2">
<h2 class="anchored" data-anchor-id="tools-for-analyzing-query-performance">Tools for Analyzing Query Performance</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/PgWYFad.png" class="img-fluid figure-img"></p>
<figcaption>Query Plan Tree Example: nodes for scan, join, filter, sort</figcaption>
</figure>
</div>
<p>How do we peek under the hood to see what Postgres is doing with our SQL? This is where performance analysis tools come in. The three primary tools we’ll discuss are:</p>
<ul>
<li><code>EXPLAIN</code></li>
<li><code>EXPLAIN ANALYZE</code></li>
<li><code>pg_stat_statements</code> (an extension for tracking query stats across the system)</li>
</ul>
<section id="explain-the-query-plan-revealed" class="level3">
<h3 class="anchored" data-anchor-id="explain-the-query-plan-revealed">EXPLAIN: The Query Plan Revealed</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/UtYqwbu.jpeg" class="img-fluid figure-img"></p>
<figcaption>Annotated EXPLAIN Output: cost, rows, node types explained</figcaption>
</figure>
</div>
<p><em>Above: Example EXPLAIN output with annotations showing cost estimates, estimated rows, and plan node types. This helps you understand how to read the plan tree and spot key details for performance analysis.</em></p>
<p>The <code>EXPLAIN</code> command in PostgreSQL shows the <em>planned execution</em> for a given query, without actually running the query. It’s like asking the planner, “Hey, how <em>would</em> you execute this if I ran it?” The output of EXPLAIN is the <strong>query plan</strong>: a tree of steps with cost estimates. Each line in an EXPLAIN output is one node in the plan (indented to show tree structure). For example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPLAIN</span> <span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> users <span class="kw">WHERE</span> user_id <span class="op">=</span> <span class="dv">1</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>might output something like:</p>
<pre><code>Seq Scan on users  (cost=0.00..19.00 rows=1 width=240)
  Filter: (user_id = 1)</code></pre>
<p>This tells us PostgreSQL plans to do a Sequential Scan on the <code>users</code> table, with an estimated cost between 0.00 and 19.00, expecting about 1 row to match (<a href="https://www.postgresql.org/docs/current/using-explain.html">PostgreSQL documentation on EXPLAIN</a>). Because perhaps <code>user_id</code> wasn’t indexed in this scenario, it has to scan. The cost numbers are in arbitrary units, not milliseconds, and are only useful relatively. The first number is the cost to get the first row, the second is the cost to get all rows. Here the planner thinks the first matching row will be found almost immediately (0.00 startup cost), and finishing scanning would be 19.00 cost units. The <code>rows=1</code> is the estimated number of rows that will pass the filter, and <code>width=240</code> is the estimated row size (in bytes). Don’t worry about width too much, it’s about memory footprint. The key info from basic EXPLAIN: <strong>what plan was chosen (Seq Scan vs Index Scan, Hash Join vs Nested Loop, etc.) and the cost/row estimates</strong>.</p>
<p>Reading a complex plan can be intimidating at first, but it’s logical. For instance:</p>
<pre><code>Hash Join  (cost=... rows=...)
  -&gt; Seq Scan on orders ...
  -&gt; Hash  (cost=...)
       -&gt; Seq Scan on customers ...</code></pre>
<p>This means it will scan <code>orders</code>, scan <code>customers</code>, build a hash on <code>customers</code>, then join to <code>orders</code>. If you see an <code>Index Scan</code> in a plan, that’s usually a sign the planner is using an index (good for selective queries). A <code>Seq Scan</code> on a very large table for a selective query is a red flag (maybe an index is missing). EXPLAIN by itself doesn’t run the query, so it’s quick and safe to use on even slow queries — but it shows only estimates, not actual runtime.</p>
<p><strong>Tip:</strong> You can use <code>EXPLAIN (VERBOSE, BUFFERS)</code> and other options for more detail. However, an even more powerful variant is EXPLAIN ANALYZE.</p>
</section>
<section id="explain-analyze-timing-the-query-execution" class="level3">
<h3 class="anchored" data-anchor-id="explain-analyze-timing-the-query-execution">EXPLAIN ANALYZE: Timing the Query Execution</h3>
<p><code>EXPLAIN ANALYZE</code> actually runs your query and then shows the plan <em>with actual execution statistics</em>. This is incredibly useful because it tells you what <em>really</em> happened, not just what was expected. The output includes additional columns like <code>(actual time=… rows=… loops=…)</code> for each plan node. For example:</p>
<pre><code>Seq Scan on users  (cost=0.00..19.00 rows=1 width=240) 
(actual time=0.026..0.030 rows=1 loops=1)
  Filter: (user_id = 1)
  Rows Removed by Filter: 999</code></pre>
<p>This tells us the seq scan actually took ~0.03 ms and found 1 row, scanning 1000 rows (999 were filtered out) (<a href="https://explain.depesz.com/">Depesz’s EXPLAIN ANALYZE visualizer</a> can help interpret these). The planner expected 1 row and got 1 – good estimate. The <code>loops=1</code> indicates how many times this node was executed (loops &gt; 1 appear in nested loops or repeated subplans). The <strong>actual time</strong> is the wall-clock time spent in that operation (it shows a start..end time range per node). The difference between actual and estimated can highlight issues: e.g., if a node estimated 100 rows but actual rows=10000, that discrepancy can explain why the query might be slower than expected (planner didn’t anticipate so much work). We often look for the slowest portion of the plan – usually a node with a high actual time.</p>
<p>Keep in mind that <code>EXPLAIN ANALYZE</code> <em>does</em> execute the query fully, so don’t use it on an UPDATE/DELETE unless you’re okay with it affecting data (or wrap it in a transaction and roll back). For SELECTs, it will actually pull all the data (though not print it out), so it takes as long as the query itself takes (plus some overhead for measurement). But the insights are gold. For performance tuning, you typically run an EXPLAIN ANALYZE on a problematic query to see where the time is going. Are we doing sequential scans that could be indexed? Is a hash join consuming a lot of time or memory? Is the actual row count way off from estimate? <code>EXPLAIN ANALYZE</code> will answer that.</p>
<p><strong>Interpreting a real example:</strong> Suppose we have a slow query joining two tables. EXPLAIN ANALYZE might show:</p>
<pre><code>Hash Join  (cost=500... rows=10000) (actual time=0.5..120.0 rows=10000 loops=1)
  Hash Cond: (orders.customer_id = customers.id)
  -&gt; Seq Scan on orders  (cost=0..400.. rows=500000) (actual time=0.02..80.00 rows=500000 loops=1)
  -&gt; Hash  (cost=300..300.. rows=100000) (actual time=0.4..20.0 rows=100000 loops=1)
       -&gt; Seq Scan on customers (cost=0..200.. rows=100000) (actual time=0.01..10.0 rows=100000 loops=1)</code></pre>
<p>This indicates it scanned 500k orders, 100k customers, built a hash of customers, and joined – the hash join took about 120 ms. If we see that and think “hmm, maybe there’s an index on <code>customer_id</code> we could use instead”, we could try to optimize it (more on that soon). The EXPLAIN ANALYZE helps pinpoint that the bulk of time was spent scanning <code>orders</code> (80 ms) and then hashing+joining (another 40 ms or so). Perhaps if we had an index and the planner chose nested loops, it might scan 100k customers and do 500k index lookups – which could be better or worse. Only testing would tell.</p>
<p>The key point: <strong>Use EXPLAIN ANALYZE to get ground truth on query performance.</strong> It will show you exactly which step is the slowest and whether the planner’s estimates are on target or not.</p>
</section>
<section id="pg_stat_statements-tracking-query-performance-over-time" class="level3">
<h3 class="anchored" data-anchor-id="pg_stat_statements-tracking-query-performance-over-time">pg_stat_statements: Tracking Query Performance Over Time</h3>
<p><code>pg_stat_statements</code> is a PostgreSQL extension that tracks execution statistics for all SQL statements. While EXPLAIN is great for one-off analysis, <code>pg_stat_statements</code> is useful to monitor and find slow queries in a running system over time. It records metrics like total time spent, number of calls, I/O counts, etc., for each query (normalized).</p>
<p>To use it, you need to enable it in the Postgres config (<code>shared_preload_libraries = 'pg_stat_statements'</code>) and install the extension in your database (<code>CREATE EXTENSION pg_stat_statements;</code>). Once that’s done, Postgres will start tracking stats. You can then query the view <code>pg_stat_statements</code>. For example, to find the most time-consuming queries overall:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">query</span>, calls, total_exec_time, mean_exec_time, <span class="kw">rows</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pg_stat_statements</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> total_exec_time <span class="kw">DESC</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">LIMIT</span> <span class="dv">5</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This would list the top 5 queries by total execution time (<a href="https://www.postgresql.org/docs/current/pgstatstatements.html">PostgreSQL documentation on pg_stat_statements</a>). Important fields in this view include:</p>
<ul>
<li><strong>query:</strong> The text of the query (with literals normalized to placeholders).</li>
<li><strong>calls:</strong> How many times that query was executed.</li>
<li><strong>total_exec_time:</strong> Cumulative time spent executing it (in milliseconds).</li>
<li><strong>mean_exec_time:</strong> Average time per execution (i.e.&nbsp;total_exec_time/calls).</li>
<li><strong>rows:</strong> Total number of rows returned or affected across all calls.</li>
<li>(There are also columns for I/O like shared_blks_hit/read, which show cache hits vs reads.)</li>
</ul>
<p>Using this, you can identify, say, “Query X has been called 1000 times and averages 200 ms – that’s a slow query we should optimize.” It’s extremely helpful in production systems to find the slow outliers or the most frequently run heavy queries.</p>
<p>For example, you might find an entry like:</p>
<p><code>SELECT * FROM products WHERE category_id = $1</code> – called 15240 times, total_exec_time 42578 ms, mean_exec_time ~2.79 ms. That might be fine (2.79 ms each). Another might be a complex join with mean_exec_time 200 ms – which is worth investigating. Without <code>pg_stat_statements</code>, you’d have to guess where the slow queries are. With it, you can just query the stats view to pinpoint them.</p>
<p>One caveat: pg_stat_statements tracks queries by their normalized text. So <code>WHERE id = 1</code> and <code>WHERE id = 2</code> are considered the same query. This is usually what you want. Just be mindful that if your application generates lots of dynamic SQL (with text differences), the view can have many entries. Typically, though, you look at the top times or those exceeding a threshold.</p>
<p><strong>Reading pg_stat_statements:</strong> If we see a query with high mean_exec_time, we’d then take that query and run EXPLAIN/ANALYZE on it to see why. pg_stat_statements is a starting point to find <em>what</em> is slow. It also lets you verify improvements: after adding an index or rewriting a query, you can see if its mean_exec_time goes down on subsequent executions.</p>
<p>Lastly, note that pg_stat_statements accumulates stats since the server started (or since you reset the stats). You might want to <code>SELECT pg_stat_statements_reset();</code> to clear stats, run a workload, then check, to focus on a specific timeframe.</p>
</section>
<section id="other-tools-briefly" class="level3">
<h3 class="anchored" data-anchor-id="other-tools-briefly">Other Tools Briefly</h3>
<p>We won’t dive deep, but be aware there are other helpful tools: - <strong>Auto-Explain</strong> (an extension to automatically log EXPLAIN ANALYZE for slow queries), - <strong>pgBadger</strong> (<a href="https://pgbadger.darold.net/">pgBadger website</a>) (a log analyzer that summarizes slow queries), - third-party monitoring systems, etc. But the foundation of manual performance analysis is usually EXPLAIN/ANALYZE and pg_stat_statements.</p>
<p>Now that we have the theory and tools in mind, let’s put this knowledge into practice with a hands-on example.</p>
</section>
</section>
<section id="hands-on-tuning-query-performance-dockerized-postgres-tutorial" class="level2">
<h2 class="anchored" data-anchor-id="hands-on-tuning-query-performance-dockerized-postgres-tutorial">Hands-On: Tuning Query Performance (Dockerized Postgres Tutorial)</h2>
<blockquote class="blockquote">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/RpKqNGf.jpeg" class="img-fluid figure-img"></p>
<figcaption>Dockerized Setup: Docker container, Postgres, client connection</figcaption>
</figure>
</div>
</blockquote>
<p>Enough talk – time to get our hands dirty. In this section, we’ll set up a local PostgreSQL environment using Docker, load some sample data, and walk through optimizing a query. Follow along step-by-step to reproduce the tests.</p>
<section id="setting-up-postgresql-in-docker" class="level3">
<h3 class="anchored" data-anchor-id="setting-up-postgresql-in-docker">1. Setting Up PostgreSQL in Docker</h3>
<p>If you have Docker installed, spinning up a PostgreSQL instance is a one-liner. We’ll run the official Postgres image with a password for the default <code>postgres</code> user:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--name</span> pg-test <span class="at">-e</span> POSTGRES_PASSWORD=mysecretpass <span class="at">-p</span> 5432:5432 <span class="at">-d</span> postgres:latest</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This downloads (if not already) the latest Postgres image and runs it in a container named <code>pg-test</code>. It exposes Postgres on port 5432 of your machine (the default port). The database is ready within a few seconds. You can connect to it using any Postgres client. For simplicity, let’s use the <code>psql</code> command-line or a tool like DBeaver/TablePlus if you prefer GUIs.</p>
<p>Once the container is up, connect to it (the user is “postgres” and password “mysecretpass” as set above):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using psql (you might need to install it if not present):</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">psql</span> <span class="at">-h</span> localhost <span class="at">-U</span> postgres </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It should prompt for the password and then give you a <code>postgres=#</code> prompt. Now we’re in!</p>
</section>
<section id="sample-dataset-preparation" class="level3">
<h3 class="anchored" data-anchor-id="sample-dataset-preparation">2. Sample Dataset Preparation</h3>
<p>We need some data to play with. You can use an existing sample database (like the PostgreSQL DVD Rental sample or Pagila). But for transparency, we’ll create our own simple schema and generate some test data using SQL. This way, we know exactly what’s in it and can easily tweak it.</p>
<p>Let’s create two tables to simulate a scenario of a simple store:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> items (</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    item_id   SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    name      TEXT,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    price     <span class="dt">INT</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">category</span>  TEXT</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> orders (</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    order_id  SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    item_id   <span class="dt">INT</span> <span class="kw">REFERENCES</span> items(item_id),</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    quantity  <span class="dt">INT</span>,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    order_date <span class="dt">TIMESTAMP</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong>items:</strong> holds products with a name, price, and category.</li>
<li><strong>orders:</strong> each order references an item and has a quantity and date.</li>
</ul>
<p>Now, we’ll insert data. We want enough rows to see performance differences (tens of thousands). We can use PostgreSQL’s <code>generate_series</code> function to quickly create lots of rows. For example, to insert 100,000 items and 100,000 orders:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Insert 100k items</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> items (name, price, <span class="kw">category</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">'Item '</span> <span class="op">||</span> g, </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">random</span>()<span class="op">*</span><span class="dv">1000</span>):<span class="ch">:int</span>, </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">CASE</span> <span class="cf">WHEN</span> g % <span class="dv">4</span> <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="st">'electronics'</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">WHEN</span> g % <span class="dv">4</span> <span class="op">=</span> <span class="dv">1</span> <span class="cf">THEN</span> <span class="st">'books'</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>       <span class="cf">WHEN</span> g % <span class="dv">4</span> <span class="op">=</span> <span class="dv">2</span> <span class="cf">THEN</span> <span class="st">'clothing'</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>       <span class="cf">ELSE</span> <span class="st">'home'</span> <span class="cf">END</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> generate_series(<span class="dv">1</span>, <span class="dv">100000</span>) <span class="kw">as</span> g;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Insert 100k orders (each for a random item)</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> orders (item_id, quantity, order_date)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">random</span>()<span class="op">*</span><span class="dv">100000</span>):<span class="ch">:int</span> <span class="op">+</span> <span class="dv">1</span>,  <span class="co">-- random item_id between 1 and 100000</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">random</span>()<span class="op">*</span><span class="dv">5</span>):<span class="ch">:int</span> <span class="op">+</span> <span class="dv">1</span>,       <span class="co">-- random quantity 1 to 6</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  NOW() <span class="op">-</span> (<span class="kw">random</span>()<span class="op">*</span><span class="dv">365</span> <span class="op">||</span> <span class="st">' days'</span>):<span class="ch">:interval</span>  <span class="co">-- random date within past year</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> generate_series(<span class="dv">1</span>, <span class="dv">100000</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(This might take a few seconds to run given 200k inserts, but it’s all happening inside the database, which is pretty fast in modern Postgres.)</p>
<p>We now have: 100k items and 100k orders, with orders distributed randomly across items.</p>
<p>Before proceeding, let’s ensure stats are up-to-date (especially because we generated data in a somewhat unusual way). Run:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ANALYZE</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This will update the planner statistics for our tables, so our upcoming EXPLAINs are based on fresh info.</p>
</section>
<section id="measuring-query-performance-with-explain-and-explain-analyze" class="level3">
<h3 class="anchored" data-anchor-id="measuring-query-performance-with-explain-and-explain-analyze">3. Measuring Query Performance with EXPLAIN and EXPLAIN ANALYZE</h3>
<p><strong>Scenario:</strong> Imagine we frequently need to query for orders of a particular item by name. Perhaps our app is asking: “Find all orders for the item named ‘Item 50000’.” A straightforward SQL for that might be:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> o.order_id, o.quantity, o.order_date</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> orders o</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> items i <span class="kw">ON</span> o.item_id <span class="op">=</span> i.item_id</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> i.name <span class="op">=</span> <span class="st">'Item 50000'</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s analyze this query’s performance.</p>
<p>First, use <code>EXPLAIN</code> to see the planned execution:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPLAIN</span> </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> o.order_id, o.quantity, o.order_date</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> orders o</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> items i <span class="kw">ON</span> o.item_id <span class="op">=</span> i.item_id</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> i.name <span class="op">=</span> <span class="st">'Item 50000'</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You might get an output (formatted for clarity) like:</p>
<pre><code>Nested Loop  (cost=0.00..???? rows=?)
  -&gt; Seq Scan on items i  (cost=0.00..???? rows=1) 
       Filter: (name = 'Item 50000')
  -&gt; Index Scan on orders  (cost=0.00..???? rows=?)
       Index Cond: (item_id = i.item_id)</code></pre>
<p><strong>What does this mean?</strong> The planner sees a filter on <code>i.name = 'Item 50000'</code>. We did NOT create an index on <code>items.name</code>, so by default, it has to Seq Scan <code>items</code> to find that item. Since there’s only one matching item (if names are unique), it estimates 1 row. For each item found (just one), it then does an Index Scan on orders… but wait, do we have an index on <code>orders.item_id</code>? We did not explicitly create one. However, recall we made <code>item_id</code> a foreign key. Postgres does <strong>not</strong> automatically index foreign keys (unlike primary keys). So currently, <code>orders.item_id</code> has no index. That means the planner cannot actually do an Index Scan on orders by item_id. Instead, likely it will do a <strong>Seq Scan on orders</strong> and filter each by matching item_id. The plan might actually be:</p>
<pre class="text"><code>Hash Join  (cost=... )
  -&gt; Seq Scan on items i ...  (filter name)
  -&gt; Seq Scan on orders o ... (filtered by hash join on item_id)</code></pre>
<p>Because without an index on <code>orders.item_id</code>, a Nested Loop using index scan isn’t possible. The planner probably chooses a Hash Join: it will read the one matching item, hash its item_id, then seq scan orders and for each order check if its item_id matches the hash (i.e., equals 50000). Since orders is 100k, that’s a 100k scan – not too bad, but not great if this query is frequent.</p>
<p>Let’s confirm by running <code>EXPLAIN ANALYZE</code> to see actual behavior and timing:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPLAIN</span> <span class="kw">ANALYZE</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> o.order_id, o.quantity, o.order_date</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> orders o</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> items i <span class="kw">ON</span> o.item_id <span class="op">=</span> i.item_id</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> i.name <span class="op">=</span> <span class="st">'Item 50000'</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You might see output indicating a hash join and the time, for example (pseudo-output):</p>
<pre class="text"><code>Hash Join  (actual time=0.2..15.0 rows=Random loops=1)
  Hash Cond: (o.item_id = i.item_id)
  -&gt; Seq Scan on orders o  (actual time=0.02..10.00 rows=100000 loops=1)
       Filter: (/* after hash cond */)
  -&gt; Hash  (actual time=0.1..0.1 rows=1 loops=1)
       Buckets: 1024  Batches: 1  Memory Usage: 9kB
       -&gt; Seq Scan on items i  (actual time=0.01..0.01 rows=1 loops=1)
             Filter: (name = 'Item 50000')
             Rows Removed by Filter: 99999</code></pre>
<p>Interpreting: it scanned 100k items to find the one with that name (took ~0.01 ms per the above – actually likely a bit more, but anyway). It found 1 row, built a tiny hash. Then it seq scanned 100k orders, and for each, applied the hash condition (which essentially checks <code>item_id = 50000</code>). It found, say, a handful of orders that matched (depends how random our data was; could be around 1 order on average since random distribution). Total time ~15 ms (most of which is scanning orders).</p>
<p>Now, 15 ms isn’t terrible, but remember this is a contrived smallish dataset on a local machine. Scale it up or have many concurrent queries and it adds up. Also, scanning 100k rows to get maybe 1 result is wasteful. We can do better by adding an index.</p>
</section>
<section id="optimizing-the-query-adding-an-index" class="level3">
<h3 class="anchored" data-anchor-id="optimizing-the-query-adding-an-index">4. Optimizing the Query: Adding an Index</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 24%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Before Index</th>
<th>After Index (on orders.item_id)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Plan Type</strong></td>
<td>Hash Join</td>
<td>Nested Loop Join</td>
</tr>
<tr class="even">
<td><strong>Plan Details</strong></td>
<td>Seq Scan on items + Seq Scan on orders</td>
<td>Seq Scan on items + Index Scan on orders</td>
</tr>
<tr class="odd">
<td><strong>Rows Scanned (orders)</strong></td>
<td>100,000 (all rows)</td>
<td>~1-3 (only matching rows)</td>
</tr>
<tr class="even">
<td><strong>Execution Time</strong></td>
<td>~15 ms</td>
<td>~0.5 ms</td>
</tr>
<tr class="odd">
<td><strong>Performance Gain</strong></td>
<td>-</td>
<td>30x faster</td>
</tr>
<tr class="even">
<td><strong>Scalability</strong></td>
<td>Poor (O(N) with table size)</td>
<td>Good (logarithmic with table size)</td>
</tr>
</tbody>
</table>
<p>The obvious optimization is to add an index on the <code>items.name</code> or on <code>orders.item_id</code> (or both). Which one helps more?</p>
<ul>
<li>Index on <code>items.name</code> would make finding “Item 50000” very fast (index lookup instead of seq scan on items). But items is only 100k rows and fairly static, and scanning 100k in memory is like ~0.01 seconds, not huge. The bigger cost was scanning orders.</li>
<li>Index on <code>orders.item_id</code> would allow Postgres to directly find all orders for item_id 50000 instead of scanning all orders. That seems more beneficial in this case.</li>
</ul>
<p>Let’s create an index on <code>orders.item_id</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_orders_item <span class="kw">ON</span> orders(item_id);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After creating the index, run <code>ANALYZE orders;</code> (to update stats for the planner to consider the new index). Now, re-run our query with EXPLAIN:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPLAIN</span> <span class="kw">SELECT</span> <span class="op">..</span>. (same <span class="kw">query</span>) <span class="op">..</span>.;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Expected new plan:</p>
<pre class="text"><code>Nested Loop  (cost=... rows=...)
  -&gt; Seq Scan on items i  (cost=... rows=1)
       Filter: (name = 'Item 50000')
  -&gt; Index Scan using idx_orders_item on orders o  (cost=... rows=??)
       Index Cond: (item_id = i.item_id)</code></pre>
<p>Because now the planner knows it can find orders by item_id quickly using the index. The Seq Scan on items remains (we didn’t index name yet), but that’s minor. The big change is an Index Scan on orders. With EXPLAIN ANALYZE, we’d likely see:</p>
<pre class="text"><code>Nested Loop  (actual time=0.1..0.5 rows=X loops=1)
  -&gt; Seq Scan on items i  (actual time=0.01..0.02 rows=1 loops=1)
       Filter: (name = 'Item 50000')
  -&gt; Index Scan using idx_orders_item on orders o  (actual time=0.05..0.40 rows=X loops=1)
       Index Cond: (item_id = i.item_id)</code></pre>
<p>The index scan will only fetch orders where item_id matches our item. If, say, there were 3 orders of Item 50000, then rows=3 for that index scan. The actual time would be very small (the index lookup is very fast, plus fetching 3 table rows). The total time might drop to ~0.5 ms or so (plus the overhead of client display). A dramatic improvement from 15 ms to ~0.5 ms, which is <strong>30x faster</strong> in this toy example. More importantly, the workload scales: even if orders table had 100 million rows, an index scan to find a few orders would remain fast (logarithmic time to traverse the index, then retrieving a few rows). The seq scan approach would balloon to scanning all 100 million rows, which is obviously much slower.</p>
<p>This demonstrates the classic <strong>index vs no-index</strong> difference. We addressed the performance by adding a missing index on the join/filter key. In real scenarios, you’d apply the same logic: find what the bottleneck is (e.g., large seq scan or sort) and see if an index or query rewrite can eliminate or reduce that heavy operation.</p>
<p><strong>What about indexing <code>items.name</code>?</strong> If we also did <code>CREATE INDEX idx_items_name ON items(name);</code>, then the planner would likely do an Index Scan on items to find “Item 50000” instead of a seq scan. That would shave that last 0.01 ms to maybe 0.005 ms – negligible for our scale. But if items were millions of rows and you frequently search by name, it’s worth indexing. The general rule: index columns that are frequently filtered or joined on. Here, <code>orders.item_id</code> was crucial to index for the join, and possibly <code>items.name</code> is worth indexing for direct lookups by name.</p>
<p>Another potential improvement, if we <em>really</em> expect this specific query a lot, might be to denormalize (store item name in orders). But that has its own trade-offs and usually not necessary with proper indexes.</p>
</section>
<section id="using-pg_stat_statements-to-verify-improvement-optional" class="level3">
<h3 class="anchored" data-anchor-id="using-pg_stat_statements-to-verify-improvement-optional">5. Using pg_stat_statements to Verify Improvement (Optional)</h3>
<p>In our simple test, we can just measure timing directly. But imagine this was a production system. Before adding the index, <code>pg_stat_statements</code> would have shown the query with a higher mean time. After adding the index, that mean time should drop.</p>
<p>If you had <code>pg_stat_statements</code> enabled, you could do something like:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> mean_exec_time, <span class="kw">rows</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pg_stat_statements</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> <span class="kw">query</span> ILIKE <span class="st">'%JOIN items i ON o.item_id = i.item_id%Item 50000%'</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(We use ILIKE with a snippet of the query to find it; in real use, you’d probably identify by an id or just look at the top slow queries.) You would see the mean_exec_time before vs after. Or simply reset stats, run the query 100 times before the index and 100 times after, and then compare the averages in pg_stat_statements. The difference should be evident (we saw ~15 ms vs ~0.5 ms per execution).</p>
</section>
<section id="other-optimization-techniques" class="level3">
<h3 class="anchored" data-anchor-id="other-optimization-techniques">6. Other Optimization Techniques</h3>
<p>In our hands-on scenario, adding an index was the obvious fix. In other cases, you might consider:</p>
<ul>
<li><p><strong>Query rewriting:</strong> e.g., if a query is doing something inefficient like SELECT in a loop or unnecessary subqueries, you can rewrite it in a set-based way or use CTEs/materialized views, etc. That’s outside our current example, but an important tool.</p></li>
<li><p><strong>Adjusting Postgres settings:</strong> For instance, enabling parallel query for large scans, or increasing <code>work_mem</code> for big sorts can help certain queries. Those are more advanced tuning steps once you identify the nature of the slow operation.</p></li>
<li><p><strong>Caching results:</strong> Sometimes if an application repeatedly runs an expensive query with the same parameters, caching the result in the application or using a materialized view in the database can bypass repeated work. Again, situational, but worth noting.</p></li>
<li><p><strong>Adding </strong>appropriate** indexes:** As we did, but with care – too many indexes slow down writes. Focus on the ones that matter for read performance hotspots. Also consider index types: e.g.&nbsp;use a GIN index for text search, etc., if that’s the bottleneck.</p></li>
<li><p><strong>Vacuum and bloat:</strong> Ensure tables aren’t bloated (which can slow scans) – autovacuum usually handles this, but if you have a lot of churn, you may need to tune it.</p></li>
<li><p><strong>Connection pooling:</strong> As mentioned, if connection overhead is an issue, using a pooler like PgBouncer can drastically cut latency for lots of short queries by reusing backends.</p></li>
</ul>
<p>Our example was straightforward and common: speeding up a selective query by indexing. In practice, many performance problems have similar straightforward solutions once identified, while some require more thought and testing.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 11%">
<col style="width: 27%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Performance Factor</th>
<th>Impact</th>
<th>Tools for Analysis</th>
<th>Optimization Techniques</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Query Planning</strong></td>
<td>High</td>
<td>EXPLAIN, EXPLAIN ANALYZE</td>
<td>Query rewriting, schema optimization</td>
</tr>
<tr class="even">
<td><strong>Indexing</strong></td>
<td>Very High</td>
<td>EXPLAIN (look for Seq Scans)</td>
<td>Create appropriate indexes on filter/join columns</td>
</tr>
<tr class="odd">
<td><strong>I/O Operations</strong></td>
<td>High</td>
<td>EXPLAIN ANALYZE (actual rows/time)</td>
<td>Optimize buffer cache, reduce disk reads</td>
</tr>
<tr class="even">
<td><strong>Table Statistics</strong></td>
<td>Medium</td>
<td>ANALYZE, pg_stat* views</td>
<td>Regular ANALYZE, monitor data changes</td>
</tr>
<tr class="odd">
<td><strong>Join Methods</strong></td>
<td>High</td>
<td>EXPLAIN (Nested Loop vs Hash Join)</td>
<td>Choose right join type, index join columns</td>
</tr>
<tr class="even">
<td><strong>Memory Usage</strong></td>
<td>Medium</td>
<td>EXPLAIN BUFFERS</td>
<td>Tune work_mem, maintenance_work_mem</td>
</tr>
<tr class="odd">
<td><strong>Connection Overhead</strong></td>
<td>Low-Medium</td>
<td>pg_stat_activity</td>
<td>Connection pooling (PgBouncer)</td>
</tr>
<tr class="even">
<td><strong>Query Complexity</strong></td>
<td>High</td>
<td>Query parsing</td>
<td>Simplify complex queries, use CTEs</td>
</tr>
<tr class="odd">
<td><strong>Concurrency</strong></td>
<td>Medium</td>
<td>pg_stat_activity</td>
<td>Manage connection limits, query timeouts</td>
</tr>
<tr class="even">
<td><strong>Data Volume</strong></td>
<td>Very High</td>
<td>Table size statistics</td>
<td>Partitioning, archiving old data</td>
</tr>
</tbody>
</table>
<p>PostgreSQL is a brilliant piece of software that usually does the right thing automatically – but as engineers, understanding <em>why</em> it does what it does allows us to write better queries and design better database schemas. We saw that under the hood, Postgres executes queries through plan nodes (scans, joins, sorts) and each has implications for performance. We used EXPLAIN and EXPLAIN ANALYZE to reveal those inner workings, and <code>pg_stat_statements</code> to find slow queries systematically. Our hands-on example showed how a seemingly innocent query can be slow without proper indexing, and how a simple index can improve it by an order of magnitude.</p>
<p>As you apply this knowledge to your own applications, keep a few things in mind (yes, a TL;DR of the TL;DR):</p>
<ul>
<li><strong>Always profile your slow queries</strong> – use EXPLAIN ANALYZE to see what’s really happening. It’s the first step in any SQL performance investigation.</li>
<li><strong>Ensure you have the right indexes</strong> for your access patterns. It’s one of the most impactful tweaks for query speed (just don’t go index-crazy without reason).</li>
<li><strong>Watch out for large sequential scans, hash joins, or sorts</strong> in plans on big tables – they often indicate areas to optimize (either via indexes or query changes).</li>
<li><strong>Use <code>pg_stat_statements</code> or logging</strong> to catch slow queries in production. You can’t optimize what you don’t know about.</li>
<li><strong>Think holistically:</strong> sometimes the fix is in the application (e.g., querying less often or in bulk), sometimes in the DB (indexes, config), sometimes in schema design (normalization vs denormalization).</li>
</ul>
<p>With a bit of practice, reading EXPLAIN output and tweaking queries becomes an immensely satisfying debugging activity – it’s like being a detective diving into the database’s brain. So the next time your API call or report is sluggish due to a database query, you know the tools and concepts to crack the case. Happy querying, and may your Postgres queries be ever speedy!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/slyracoon23\.github\.io\/blog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="light">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "Slyracoon23/blog";
    script.dataset.repoId = "R_kgDOOD0L5w";
    script.dataset.category = "Announcements";
    script.dataset.categoryId = "DIC_kwDOOD0L584CopEq";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "bottom";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><i class="fa-regular fa-copyright" aria-label="copyright"></i> Copyright 2025, Earl Potters</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>